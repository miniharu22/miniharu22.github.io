---
layout : single
title: "[Verilog] Arithmetic Part (w/Testbench)"
categories: 
  - Universal NPU-CNN Accelarator
toc: true
toc_sticky: true
use_math: true
---

8개의 Arithmetic Core를 지닌 Arithmetic Part 모듈 설계 + 테스트벤치 작성      

## 0. Arithmetic Part Module    

```verilog
// Arithmetic Part module including eight Arithmetic cores
module AP(in, weight, bias, bound_level, step, en, en_relu, en_mp, out, out_en, clk, reset);

    parameter cell_bit = 8;
    parameter N_cell = 9;
    parameter biasport = 16;
    parameter N_core = 8;
    parameter outport = 8;

    input [cell_bit*N_cell-1:0] in;             // 72bits Input feature map
    input [cell_bit*N_cell*N_core-1:0] weight;  // 72bits weight x 8
    input [biasport*N_core-1:0] bias;           // 16bit bias x 8
    input [2:0] bound_level;
    input [2:0] step;
    input en, en_relu, en_mp;
    input clk, reset;

    output [outport*N_core-1:0] out;            // 8bit output x 8
    output [N_core-1:0] out_en;                 

    genvar i;
    generate
    for(i=0; i<N_core; i=i+1) begin : generate_ac
        arithmetic_core_mod ac (in, 
                                weight[cell_bit*N_cell*N_core-cell_bit*N_cell*i-1-:cell_bit*N_cell], 
                                bias[biasport*N_core-biasport*i-1-:biasport],
                                bound_level, 
                                step, 
                                en, 
                                en_relu, 
                                en_mp,
                                out[outport*N_core-outport*i-1-:outport], 
                                out_en[N_core-i-1], 
                                clk, 
                                reset);
    end
    endgenerate

endmodule
```

<div align="left">
    <strong>RTL Schematic</strong>
  <img src="/assets/images/npu/115.png" width="100%" height="100%" alt=""/>
  <p><em></em></p>
</div>
{: .notice} 

- **AP (Arithmetic Part) 모듈**  
  - 8개의 `arithmetic_core_mod`를 병렬로 생성하여 CNN-like 연산을 병렬 처리하는 상위 모듈  
  - 각 코어는 동일한 입력 feature map을 공유하며, 개별 filter weight와 bias를 사용  
  - 제어 신호를 통해 ReLU, Max pooling 단계를 활성화 가능      

  - **데이터 처리 과정**  
    - **1단계: 입력**  
      - **입력 feature map**: `in` (9개의 입력 cell, 각 8비트)  
      - **가중치**: `weight` (8개의 filter, 각 filter는 9개의 8비트 weight)  
      - **편향**: `bias` (8개의 16비트 bias 값)  
      - **제어 신호**:  
        - `bound_level`: clipping 단계 제어 (3비트)  
        - `step`: 누적합산 단계 제어 (3비트)  
        - `en`: 연산 활성화  
        - `en_relu`: ReLU 활성화  
        - `en_mp`: Max pooling 활성화  
        - `clk`, `reset`: 동작 클럭 및 리셋  

    - **2단계: 코어별 연산 처리**  
      - `generate` 블록으로 8개의 코어(`arithmetic_core_mod`)를 생성  
      - 각 코어는 같은 입력 feature map(`in`)을 사용  
      - 각 코어는 자신에게 해당하는 filter weight와 bias를 선택적으로 받아 처리  
      - 비트 슬라이싱을 통해 가중치, bias, 출력 포트를 정확히 할당  
      - 코어별 결과:  
        - 출력값: `out` (코어별 8비트 결과, 총 64비트)  
        - 출력 유효 신호: `out_en` (코어별 1비트)  

    - **3단계: 내부 처리 (코어 내부)**  
      - 각 코어(`arithmetic_core_mod`)는 다음과 같은 연산을 수행:  
        - 입력 feature map과 가중치의 곱셈 및 누적합산 (Convolution 연산)  
        - clipping 처리 & 9개 이상의 weight 누적 합산 (bound_level 및 step 사용)  
        - ReLU 처리(`en_relu=1`일 때 음수 제거)  
        - Max pooling 처리(`en_mp=1`일 때 2x2 영역의 최댓값 출력)  
        - 최종 출력값과 유효 신호 생성  

    - **4단계: 출력**  
      - 8개의 코어가 각자 출력값(`out`)과 출력 유효 신호(`out_en`)를 병렬로 생성  
      - 결과적으로 최종 출력값은 8개의 코어 출력이 직렬로 결합된 형태 (64비트)     

&nbsp;


